{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.observable = observable;\nexports.cleanupEffect = cleanupEffect;\nfunction observable(value, {\n  fallback,\n  name\n} = {}) {\n  const effects = new Set();\n  return {\n    name,\n    get(effect) {\n      if (effect) {\n        effects.add(effect);\n        effect.dependencies.add(() => effects.delete(effect));\n      }\n      return value ?? fallback?.get(effect);\n    },\n    set(newValue) {\n      if (Object.is(newValue, value)) return;\n      value = newValue;\n      for (const effect of Array.from(effects)) {\n        effect.run();\n      }\n    }\n  };\n}\nfunction cleanupEffect(effect) {\n  for (const dep of Array.from(effect.dependencies)) {\n    dep();\n  }\n  effect.dependencies.clear();\n}","map":{"version":3,"names":["exports","observable","cleanupEffect","value","fallback","name","effects","Set","get","effect","add","dependencies","delete","set","newValue","Object","is","Array","from","run","dep","clear"],"sources":["C:\\Users\\RYZEN 7\\Documents\\Code\\styles_test\\example_app\\AwesomeProject\\node_modules\\react-native-css-interop\\src\\runtime\\observable.ts"],"sourcesContent":["/**\n * Observer pattern implementation\n *\n * Observables are used to store reactive values. When you access the value of an Observable,\n * with an Effect, it will subscribe the Effect to the Observable. When the value of the Observable\n * is changed, it will rerun all subscribed Effects.\n */\n\nexport type Observable<T> = {\n  // Used for debugging only\n  name?: string;\n  // Get the current value of the observable. If you provide an Effect, it will be subscribed to the observable.\n  get(effect?: Effect): T;\n  // Set the value and rerun all subscribed Effects\n  set(newValue: T): void;\n};\n\nexport type ReadableObservable<T> = Pick<Observable<T>, \"get\" | \"name\">;\n\n/**\n * An Effect is a function that will be rerun when its dependencies change.\n */\nexport type Effect = {\n  run: () => void;\n  dependencies: Set<() => void>;\n};\n\nexport type ObservableOptions<T> = {\n  fallback?: Observable<T>;\n  name?: string;\n};\n\nexport function observable<T>(\n  value: T,\n  { fallback, name }: ObservableOptions<T> = {},\n): Observable<T> {\n  const effects = new Set<Effect>();\n\n  return {\n    name,\n    get(effect) {\n      if (effect) {\n        // Subscribe the effect to the observable\n        effects.add(effect);\n        effect.dependencies.add(() => effects.delete(effect));\n      }\n      return value ?? fallback?.get(effect)!;\n    },\n\n    set(newValue: any) {\n      if (Object.is(newValue, value)) return;\n      value = newValue;\n      // We changed, so rerun all subscribed effects\n      // We need to copy the effects set because rerunning an effect might resubscribe it\n      for (const effect of Array.from(effects)) {\n        effect.run();\n      }\n    },\n  };\n}\n\nexport function cleanupEffect(effect: Effect) {\n  for (const dep of Array.from(effect.dependencies)) {\n    dep();\n  }\n  effect.dependencies.clear();\n}\n"],"mappings":";;;;;AAgCAA,OAAA,CAAAC,UAAA,GAAAA,UAAA;AA6BAD,OAAA,CAAAE,aAAA,GAAAA,aAAA;AA7BA,SAAgBD,UAAUA,CACxBE,KAAQ,EACR;EAAEC,QAAQ;EAAEC;AAAI,IAA2B,EAAE;EAE7C,MAAMC,OAAO,GAAG,IAAIC,GAAG,EAAU;EAEjC,OAAO;IACLF,IAAI;IACJG,GAAGA,CAACC,MAAM;MACR,IAAIA,MAAM,EAAE;QAEVH,OAAO,CAACI,GAAG,CAACD,MAAM,CAAC;QACnBA,MAAM,CAACE,YAAY,CAACD,GAAG,CAAC,MAAMJ,OAAO,CAACM,MAAM,CAACH,MAAM,CAAC,CAAC;MACvD;MACA,OAAON,KAAK,IAAIC,QAAQ,EAAEI,GAAG,CAACC,MAAM,CAAE;IACxC,CAAC;IAEDI,GAAGA,CAACC,QAAa;MACf,IAAIC,MAAM,CAACC,EAAE,CAACF,QAAQ,EAAEX,KAAK,CAAC,EAAE;MAChCA,KAAK,GAAGW,QAAQ;MAGhB,KAAK,MAAML,MAAM,IAAIQ,KAAK,CAACC,IAAI,CAACZ,OAAO,CAAC,EAAE;QACxCG,MAAM,CAACU,GAAG,EAAE;MACd;IACF;GACD;AACH;AAEA,SAAgBjB,aAAaA,CAACO,MAAc;EAC1C,KAAK,MAAMW,GAAG,IAAIH,KAAK,CAACC,IAAI,CAACT,MAAM,CAACE,YAAY,CAAC,EAAE;IACjDS,GAAG,EAAE;EACP;EACAX,MAAM,CAACE,YAAY,CAACU,KAAK,EAAE;AAC7B","ignoreList":[]},"metadata":{"hasCjsExports":true},"sourceType":"script","externalDependencies":[]}